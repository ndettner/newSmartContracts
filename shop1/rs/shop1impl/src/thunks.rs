// Code generated by schema tool; DO NOT EDIT.

#![allow(dead_code)]
#![allow(unused_imports)]

use wasmlib::*;
use shop1::*;
use crate::*;

const EXPORT_MAP: ScExportMap = ScExportMap {
    names: &[
        FUNC_CALL_CHECK_PRODUCT,
        FUNC_CALL_CREATE_NEW_PRODUCT,
        FUNC_CALL_PAY_STORE,
        FUNC_CALL_PING_SHOP,
        FUNC_CALL_RECIEVE_PRODUCTS,
        FUNC_CALL_SEND_PRODUCT,
        FUNC_INIT,
        FUNC_PRODUCE,
        FUNC_SET_OWNER,
        FUNC_START_PRODUCTION,
        VIEW_CALL_GET_SHOP_STATISTICS,
        VIEW_GET_EARNINGS,
        VIEW_GET_MAX_PRODUCTION_STEPS,
        VIEW_GET_OWNER,
        VIEW_GET_PRODUCED_PRODUCTS,
        VIEW_GET_PRODUCTS_IN_PRODUCTION,
        VIEW_GET_SOLD_PRODUCTS,
    ],
    funcs: &[
        func_call_check_product_thunk,
        func_call_create_new_product_thunk,
        func_call_pay_store_thunk,
        func_call_ping_shop_thunk,
        func_call_recieve_products_thunk,
        func_call_send_product_thunk,
        func_init_thunk,
        func_produce_thunk,
        func_set_owner_thunk,
        func_start_production_thunk,
    ],
    views: &[
        view_call_get_shop_statistics_thunk,
        view_get_earnings_thunk,
        view_get_max_production_steps_thunk,
        view_get_owner_thunk,
        view_get_produced_products_thunk,
        view_get_products_in_production_thunk,
        view_get_sold_products_thunk,
    ],
};

pub fn on_dispatch(index: i32) {
    EXPORT_MAP.dispatch(index);
}

pub struct CallCheckProductContext {
    pub params:  ImmutableCallCheckProductParams,
    pub results: MutableCallCheckProductResults,
    pub state:   Mutableshop1State,
}

fn func_call_check_product_thunk(ctx: &ScFuncContext) {
    ctx.log("shop1.funcCallCheckProduct");
    let f = CallCheckProductContext {
        params:  ImmutableCallCheckProductParams::new(),
        results: MutableCallCheckProductResults::new(),
        state:   Mutableshop1State::new(),
    };
    func_call_check_product(ctx, &f);
    ctx.results(&f.results.proxy);
    ctx.log("shop1.funcCallCheckProduct ok");
}

pub struct CallCreateNewProductContext {
    pub params: ImmutableCallCreateNewProductParams,
    pub state:  Mutableshop1State,
}

fn func_call_create_new_product_thunk(ctx: &ScFuncContext) {
    ctx.log("shop1.funcCallCreateNewProduct");
    let f = CallCreateNewProductContext {
        params: ImmutableCallCreateNewProductParams::new(),
        state:  Mutableshop1State::new(),
    };
    ctx.require(f.params.musician_name().exists(), "missing mandatory param: musicianName");
    ctx.require(f.params.price().exists(), "missing mandatory param: price");
    ctx.require(f.params.product_type().exists(), "missing mandatory param: productType");
    ctx.require(f.params.shop_name().exists(), "missing mandatory param: shopName");
    func_call_create_new_product(ctx, &f);
    ctx.log("shop1.funcCallCreateNewProduct ok");
}

pub struct CallPayStoreContext {
    pub params: ImmutableCallPayStoreParams,
    pub state:  Mutableshop1State,
}

fn func_call_pay_store_thunk(ctx: &ScFuncContext) {
    ctx.log("shop1.funcCallPayStore");
    let f = CallPayStoreContext {
        params: ImmutableCallPayStoreParams::new(),
        state:  Mutableshop1State::new(),
    };
    ctx.require(f.params.shop_name().exists(), "missing mandatory param: shopName");
    func_call_pay_store(ctx, &f);
    ctx.log("shop1.funcCallPayStore ok");
}

pub struct CallPingShopContext {
    pub results: MutableCallPingShopResults,
    pub state:   Mutableshop1State,
}

fn func_call_ping_shop_thunk(ctx: &ScFuncContext) {
    ctx.log("shop1.funcCallPingShop");
    let f = CallPingShopContext {
        results: MutableCallPingShopResults::new(),
        state:   Mutableshop1State::new(),
    };
    func_call_ping_shop(ctx, &f);
    ctx.results(&f.results.proxy);
    ctx.log("shop1.funcCallPingShop ok");
}

pub struct CallRecieveProductsContext {
    pub results: MutableCallRecieveProductsResults,
    pub state:   Mutableshop1State,
}

fn func_call_recieve_products_thunk(ctx: &ScFuncContext) {
    ctx.log("shop1.funcCallRecieveProducts");
    let f = CallRecieveProductsContext {
        results: MutableCallRecieveProductsResults::new(),
        state:   Mutableshop1State::new(),
    };
    func_call_recieve_products(ctx, &f);
    ctx.results(&f.results.proxy);
    ctx.log("shop1.funcCallRecieveProducts ok");
}

pub struct CallSendProductContext {
    pub state: Mutableshop1State,
}

fn func_call_send_product_thunk(ctx: &ScFuncContext) {
    ctx.log("shop1.funcCallSendProduct");
    let f = CallSendProductContext {
        state: Mutableshop1State::new(),
    };
    func_call_send_product(ctx, &f);
    ctx.log("shop1.funcCallSendProduct ok");
}

pub struct InitContext {
    pub params: ImmutableInitParams,
    pub state:  Mutableshop1State,
}

fn func_init_thunk(ctx: &ScFuncContext) {
    ctx.log("shop1.funcInit");
    let f = InitContext {
        params: ImmutableInitParams::new(),
        state:  Mutableshop1State::new(),
    };
    func_init(ctx, &f);
    ctx.log("shop1.funcInit ok");
}

pub struct ProduceContext {
    pub state: Mutableshop1State,
}

fn func_produce_thunk(ctx: &ScFuncContext) {
    ctx.log("shop1.funcProduce");
    let f = ProduceContext {
        state: Mutableshop1State::new(),
    };

    // only SC can produce
    ctx.require(ctx.caller() == ctx.account_id(), "no permission");

    func_produce(ctx, &f);
    ctx.log("shop1.funcProduce ok");
}

pub struct SetOwnerContext {
    pub params: ImmutableSetOwnerParams,
    pub state:  Mutableshop1State,
}

fn func_set_owner_thunk(ctx: &ScFuncContext) {
    ctx.log("shop1.funcSetOwner");
    let f = SetOwnerContext {
        params: ImmutableSetOwnerParams::new(),
        state:  Mutableshop1State::new(),
    };
    ctx.require(f.params.owner().exists(), "missing mandatory param: owner");
    func_set_owner(ctx, &f);
    ctx.log("shop1.funcSetOwner ok");
}

pub struct StartProductionContext {
    pub state: Mutableshop1State,
}

fn func_start_production_thunk(ctx: &ScFuncContext) {
    ctx.log("shop1.funcStartProduction");
    let f = StartProductionContext {
        state: Mutableshop1State::new(),
    };

    // current owner of this smart contract
    let access = f.state.owner();
    ctx.require(access.exists(), "access not set: owner");
    ctx.require(ctx.caller() == access.value(), "no permission");

    func_start_production(ctx, &f);
    ctx.log("shop1.funcStartProduction ok");
}

pub struct CallGetShopStatisticsContext {
    pub params:  ImmutableCallGetShopStatisticsParams,
    pub results: MutableCallGetShopStatisticsResults,
    pub state:   Immutableshop1State,
}

fn view_call_get_shop_statistics_thunk(ctx: &ScViewContext) {
    ctx.log("shop1.viewCallGetShopStatistics");
    let f = CallGetShopStatisticsContext {
        params:  ImmutableCallGetShopStatisticsParams::new(),
        results: MutableCallGetShopStatisticsResults::new(),
        state:   Immutableshop1State::new(),
    };
    ctx.require(f.params.shop_name().exists(), "missing mandatory param: shopName");
    view_call_get_shop_statistics(ctx, &f);
    ctx.results(&f.results.proxy);
    ctx.log("shop1.viewCallGetShopStatistics ok");
}

pub struct GetEarningsContext {
    pub results: MutableGetEarningsResults,
    pub state:   Immutableshop1State,
}

fn view_get_earnings_thunk(ctx: &ScViewContext) {
    ctx.log("shop1.viewGetEarnings");
    let f = GetEarningsContext {
        results: MutableGetEarningsResults::new(),
        state:   Immutableshop1State::new(),
    };
    view_get_earnings(ctx, &f);
    ctx.results(&f.results.proxy);
    ctx.log("shop1.viewGetEarnings ok");
}

pub struct GetMaxProductionStepsContext {
    pub results: MutableGetMaxProductionStepsResults,
    pub state:   Immutableshop1State,
}

fn view_get_max_production_steps_thunk(ctx: &ScViewContext) {
    ctx.log("shop1.viewGetMaxProductionSteps");
    let f = GetMaxProductionStepsContext {
        results: MutableGetMaxProductionStepsResults::new(),
        state:   Immutableshop1State::new(),
    };
    view_get_max_production_steps(ctx, &f);
    ctx.results(&f.results.proxy);
    ctx.log("shop1.viewGetMaxProductionSteps ok");
}

pub struct GetOwnerContext {
    pub results: MutableGetOwnerResults,
    pub state:   Immutableshop1State,
}

fn view_get_owner_thunk(ctx: &ScViewContext) {
    ctx.log("shop1.viewGetOwner");
    let f = GetOwnerContext {
        results: MutableGetOwnerResults::new(),
        state:   Immutableshop1State::new(),
    };
    view_get_owner(ctx, &f);
    ctx.results(&f.results.proxy);
    ctx.log("shop1.viewGetOwner ok");
}

pub struct GetProducedProductsContext {
    pub results: MutableGetProducedProductsResults,
    pub state:   Immutableshop1State,
}

fn view_get_produced_products_thunk(ctx: &ScViewContext) {
    ctx.log("shop1.viewGetProducedProducts");
    let f = GetProducedProductsContext {
        results: MutableGetProducedProductsResults::new(),
        state:   Immutableshop1State::new(),
    };
    view_get_produced_products(ctx, &f);
    ctx.results(&f.results.proxy);
    ctx.log("shop1.viewGetProducedProducts ok");
}

pub struct GetProductsInProductionContext {
    pub results: MutableGetProductsInProductionResults,
    pub state:   Immutableshop1State,
}

fn view_get_products_in_production_thunk(ctx: &ScViewContext) {
    ctx.log("shop1.viewGetProductsInProduction");
    let f = GetProductsInProductionContext {
        results: MutableGetProductsInProductionResults::new(),
        state:   Immutableshop1State::new(),
    };
    view_get_products_in_production(ctx, &f);
    ctx.results(&f.results.proxy);
    ctx.log("shop1.viewGetProductsInProduction ok");
}

pub struct GetSoldProductsContext {
    pub results: MutableGetSoldProductsResults,
    pub state:   Immutableshop1State,
}

fn view_get_sold_products_thunk(ctx: &ScViewContext) {
    ctx.log("shop1.viewGetSoldProducts");
    let f = GetSoldProductsContext {
        results: MutableGetSoldProductsResults::new(),
        state:   Immutableshop1State::new(),
    };
    view_get_sold_products(ctx, &f);
    ctx.results(&f.results.proxy);
    ctx.log("shop1.viewGetSoldProducts ok");
}
