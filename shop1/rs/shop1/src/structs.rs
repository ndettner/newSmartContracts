// Code generated by schema tool; DO NOT EDIT.

#![allow(dead_code)]
#![allow(unused_imports)]

use wasmlib::*;

#[derive(Clone)]
pub struct Product {
    // Associated Musician
    pub musician     : String,
    // Price of product
    pub price        : u64,
    // type of Product e.g. Tshirt
    pub product_type : String,
    // shopName
    pub shop_name    : String,
    // Available Stock
    pub stock        : u64,
}

impl Product {
    pub fn from_bytes(bytes: &[u8]) -> Product {
        let mut dec = WasmDecoder::new(bytes);
        Product {
            musician     : string_decode(&mut dec),
            price        : uint64_decode(&mut dec),
            product_type : string_decode(&mut dec),
            shop_name    : string_decode(&mut dec),
            stock        : uint64_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
        string_encode(&mut enc, &self.musician);
        uint64_encode(&mut enc, self.price);
        string_encode(&mut enc, &self.product_type);
        string_encode(&mut enc, &self.shop_name);
        uint64_encode(&mut enc, self.stock);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableProduct {
    pub(crate) proxy: Proxy,
}

impl ImmutableProduct {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> Product {
        Product::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableProduct {
    pub(crate) proxy: Proxy,
}

impl MutableProduct {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &Product) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> Product {
        Product::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct ProductTemplate {
    // Associated Musician
    pub musician     : String,
    // Price of product
    pub price        : u64,
    // type of Product e.g. Tshirt
    pub product_type : String,
    // name of the Shop
    pub shop_name    : String,
}

impl ProductTemplate {
    pub fn from_bytes(bytes: &[u8]) -> ProductTemplate {
        let mut dec = WasmDecoder::new(bytes);
        ProductTemplate {
            musician     : string_decode(&mut dec),
            price        : uint64_decode(&mut dec),
            product_type : string_decode(&mut dec),
            shop_name    : string_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
        string_encode(&mut enc, &self.musician);
        uint64_encode(&mut enc, self.price);
        string_encode(&mut enc, &self.product_type);
        string_encode(&mut enc, &self.shop_name);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableProductTemplate {
    pub(crate) proxy: Proxy,
}

impl ImmutableProductTemplate {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> ProductTemplate {
        ProductTemplate::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableProductTemplate {
    pub(crate) proxy: Proxy,
}

impl MutableProductTemplate {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &ProductTemplate) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> ProductTemplate {
        ProductTemplate::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct StatisticProduct {
    // id of product
    pub id              : u64,
    // Associated Musician
    pub musician        : String,
    // Price of product
    pub price           : u64,
    // Index of production plant
    pub production_step : u64,
    // type of Product e.g. Tshirt
    pub product_type    : String,
    // name of the Shop
    pub shop_name       : String,
    // Timestampt since last production step
    pub timestamp       : u64,
}

impl StatisticProduct {
    pub fn from_bytes(bytes: &[u8]) -> StatisticProduct {
        let mut dec = WasmDecoder::new(bytes);
        StatisticProduct {
            id              : uint64_decode(&mut dec),
            musician        : string_decode(&mut dec),
            price           : uint64_decode(&mut dec),
            production_step : uint64_decode(&mut dec),
            product_type    : string_decode(&mut dec),
            shop_name       : string_decode(&mut dec),
            timestamp       : uint64_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
        uint64_encode(&mut enc, self.id);
        string_encode(&mut enc, &self.musician);
        uint64_encode(&mut enc, self.price);
        uint64_encode(&mut enc, self.production_step);
        string_encode(&mut enc, &self.product_type);
        string_encode(&mut enc, &self.shop_name);
        uint64_encode(&mut enc, self.timestamp);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableStatisticProduct {
    pub(crate) proxy: Proxy,
}

impl ImmutableStatisticProduct {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> StatisticProduct {
        StatisticProduct::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableStatisticProduct {
    pub(crate) proxy: Proxy,
}

impl MutableStatisticProduct {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &StatisticProduct) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> StatisticProduct {
        StatisticProduct::from_bytes(&self.proxy.get())
    }
}
