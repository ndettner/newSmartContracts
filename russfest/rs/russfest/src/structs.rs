// Code generated by schema tool; DO NOT EDIT.

#![allow(dead_code)]
#![allow(unused_imports)]

use wasmlib::*;

#[derive(Clone)]
pub struct Musician {
    // Name of the musician
    pub name : String,
    // Name of associated Shop
    pub shop : String,
}

impl Musician {
    pub fn from_bytes(bytes: &[u8]) -> Musician {
        let mut dec = WasmDecoder::new(bytes);
        Musician {
            name : string_decode(&mut dec),
            shop : string_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
        string_encode(&mut enc, &self.name);
        string_encode(&mut enc, &self.shop);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableMusician {
    pub(crate) proxy: Proxy,
}

impl ImmutableMusician {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> Musician {
        Musician::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableMusician {
    pub(crate) proxy: Proxy,
}

impl MutableMusician {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &Musician) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> Musician {
        Musician::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct Product {
    // Associated Musician
    pub musician     : String,
    // Price of product
    pub price        : u64,
    // type of Product e.g. Tshirt
    pub product_type : String,
    // shopName
    pub shop_name    : String,
    // Available Stock
    pub stock        : u64,
}

impl Product {
    pub fn from_bytes(bytes: &[u8]) -> Product {
        let mut dec = WasmDecoder::new(bytes);
        Product {
            musician     : string_decode(&mut dec),
            price        : uint64_decode(&mut dec),
            product_type : string_decode(&mut dec),
            shop_name    : string_decode(&mut dec),
            stock        : uint64_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
        string_encode(&mut enc, &self.musician);
        uint64_encode(&mut enc, self.price);
        string_encode(&mut enc, &self.product_type);
        string_encode(&mut enc, &self.shop_name);
        uint64_encode(&mut enc, self.stock);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableProduct {
    pub(crate) proxy: Proxy,
}

impl ImmutableProduct {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> Product {
        Product::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableProduct {
    pub(crate) proxy: Proxy,
}

impl MutableProduct {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &Product) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> Product {
        Product::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct ProductTemplate {
    // Associated Musician
    pub musician     : String,
    // Price of product
    pub price        : u64,
    // type of Product e.g. Tshirt
    pub product_type : String,
    // name of the Shop
    pub shop_name    : String,
}

impl ProductTemplate {
    pub fn from_bytes(bytes: &[u8]) -> ProductTemplate {
        let mut dec = WasmDecoder::new(bytes);
        ProductTemplate {
            musician     : string_decode(&mut dec),
            price        : uint64_decode(&mut dec),
            product_type : string_decode(&mut dec),
            shop_name    : string_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
        string_encode(&mut enc, &self.musician);
        uint64_encode(&mut enc, self.price);
        string_encode(&mut enc, &self.product_type);
        string_encode(&mut enc, &self.shop_name);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableProductTemplate {
    pub(crate) proxy: Proxy,
}

impl ImmutableProductTemplate {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> ProductTemplate {
        ProductTemplate::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableProductTemplate {
    pub(crate) proxy: Proxy,
}

impl MutableProductTemplate {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &ProductTemplate) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> ProductTemplate {
        ProductTemplate::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct Shop {
    // Fee the Shop wants to pay
    pub fee           : u64,
    // Sets if Shop is registered or still has open request
    pub is_registered : String,
    // Name of the musician
    pub musician_name : String,
    // hName of Shop
    pub shop_hname    : ScHname,
    // Name of the Shop
    pub shop_name     : String,
    // Address of ShopOwner
    pub shop_owner    : ScAgentID,
}

impl Shop {
    pub fn from_bytes(bytes: &[u8]) -> Shop {
        let mut dec = WasmDecoder::new(bytes);
        Shop {
            fee           : uint64_decode(&mut dec),
            is_registered : string_decode(&mut dec),
            musician_name : string_decode(&mut dec),
            shop_hname    : hname_decode(&mut dec),
            shop_name     : string_decode(&mut dec),
            shop_owner    : agent_id_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
        uint64_encode(&mut enc, self.fee);
        string_encode(&mut enc, &self.is_registered);
        string_encode(&mut enc, &self.musician_name);
        hname_encode(&mut enc, self.shop_hname);
        string_encode(&mut enc, &self.shop_name);
        agent_id_encode(&mut enc, &self.shop_owner);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableShop {
    pub(crate) proxy: Proxy,
}

impl ImmutableShop {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> Shop {
        Shop::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableShop {
    pub(crate) proxy: Proxy,
}

impl MutableShop {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &Shop) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> Shop {
        Shop::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct StatisticProduct {
    // id of product
    pub id              : u64,
    // Associated Musician
    pub musician        : String,
    // Price of product
    pub price           : u64,
    // Index of production plant
    pub production_step : u64,
    // type of Product e.g. Tshirt
    pub product_type    : String,
    // name of the Shop
    pub shop_name       : String,
    // Timestampt since last production step
    pub timestamp       : u64,
}

impl StatisticProduct {
    pub fn from_bytes(bytes: &[u8]) -> StatisticProduct {
        let mut dec = WasmDecoder::new(bytes);
        StatisticProduct {
            id              : uint64_decode(&mut dec),
            musician        : string_decode(&mut dec),
            price           : uint64_decode(&mut dec),
            production_step : uint64_decode(&mut dec),
            product_type    : string_decode(&mut dec),
            shop_name       : string_decode(&mut dec),
            timestamp       : uint64_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
        uint64_encode(&mut enc, self.id);
        string_encode(&mut enc, &self.musician);
        uint64_encode(&mut enc, self.price);
        uint64_encode(&mut enc, self.production_step);
        string_encode(&mut enc, &self.product_type);
        string_encode(&mut enc, &self.shop_name);
        uint64_encode(&mut enc, self.timestamp);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableStatisticProduct {
    pub(crate) proxy: Proxy,
}

impl ImmutableStatisticProduct {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> StatisticProduct {
        StatisticProduct::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableStatisticProduct {
    pub(crate) proxy: Proxy,
}

impl MutableStatisticProduct {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &StatisticProduct) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> StatisticProduct {
        StatisticProduct::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct Timeslot {
    // enddtime of Timeslot
    pub end      : u64,
    // name of the musician
    pub musician : String,
    // starttime of Timeslot
    pub start    : u64,
}

impl Timeslot {
    pub fn from_bytes(bytes: &[u8]) -> Timeslot {
        let mut dec = WasmDecoder::new(bytes);
        Timeslot {
            end      : uint64_decode(&mut dec),
            musician : string_decode(&mut dec),
            start    : uint64_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
        uint64_encode(&mut enc, self.end);
        string_encode(&mut enc, &self.musician);
        uint64_encode(&mut enc, self.start);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableTimeslot {
    pub(crate) proxy: Proxy,
}

impl ImmutableTimeslot {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> Timeslot {
        Timeslot::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableTimeslot {
    pub(crate) proxy: Proxy,
}

impl MutableTimeslot {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &Timeslot) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> Timeslot {
        Timeslot::from_bytes(&self.proxy.get())
    }
}
